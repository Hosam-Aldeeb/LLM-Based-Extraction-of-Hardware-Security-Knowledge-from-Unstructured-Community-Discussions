{
  "query": "cybersecurity hardware hacking vulnerabilities exploits \nJTAG UART SPI I2C firmware reverse engineering \ndebugging bootloader flash memory encryption \nsecurity vulnerabilities penetration testing \nexploit development buffer overflow \nhardware security embedded systems IoT security",
  "threshold": 0.55,
  "source": "./discord-exports/Adafruit_helpwithhwdesign_Jan2025_export.json",
  "totalMessages": 3983,
  "totalChunks": 4015,
  "relevantMessages": 16,
  "results": [
    {
      "text": "USB IF should be 1.1 PHY so as long as they are roughly the same length and 8-10mil is size (assuming you’re using mil not mm) should be fine. UART often wants termination resistors though it will be dependent on the UART chip you use and what the data sheet specifies",
      "metadata": {
        "id": "1325577602433548388",
        "author": "skerr92",
        "timestamp": "2025-01-05T16:32:08.461-05:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5503286062095261
    },
    {
      "text": "most microcontrollers have multiple functions on a pin, so though it could be a UART it might be used as something else.",
      "metadata": {
        "id": "1327069412670439444",
        "author": "danhalbert",
        "timestamp": "2025-01-09T19:20:03.738-05:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5555836205012266
    },
    {
      "text": "One bit of industrial kit I reverse engineered wanted data at 600bps.  I had to hack up my terminal program, as it didn't offer that option.",
      "metadata": {
        "id": "1327099740244021300",
        "author": "madbodger",
        "timestamp": "2025-01-09T21:20:34.395-05:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5661736174243232
    },
    {
      "text": "Hio All,  Pullups on I2C operating at +3v3. 4.7K?",
      "metadata": {
        "id": "1328134420531511347",
        "author": "mrgamecase",
        "timestamp": "2025-01-12T17:52:01.399-05:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5540341264300626
    },
    {
      "text": "but the qspi CS is a big clue. it’s all wiggily",
      "metadata": {
        "id": "1332505874270257152",
        "author": "baldengineer",
        "timestamp": "2025-01-24T19:22:37.188-05:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5699068554170995
    },
    {
      "text": "it's the jlcpcb basic parts lib switch so that would be pretty wild",
      "metadata": {
        "id": "1332510276053893314",
        "author": "vexst",
        "timestamp": "2025-01-24T19:40:06.655-05:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5579944722931047
    },
    {
      "text": "What kind of wiring mistake could cause the 3v regulator on the esp32 s3 feather to combust when plugged in via USB?",
      "metadata": {
        "id": "1342643341245943839",
        "author": "djerba02",
        "timestamp": "2025-02-21T18:45:17.66-05:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5662720160207964
    },
    {
      "text": "Ok so I am a software engineer that works on embedded platforms and dabbles with hobby projects I have a question for some one a bit more hardware creditable than me",
      "metadata": {
        "id": "1352730785014349885",
        "author": "bahamutkotd",
        "timestamp": "2025-03-21T15:49:11.67-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5967980604499442
    },
    {
      "text": "If it's still working, you could put probes on the lines and try to decode the I2C traffic. You could get the I2C address and go from there",
      "metadata": {
        "id": "1353786192654762111",
        "author": "danhalbert",
        "timestamp": "2025-03-24T13:43:00.46-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5829372355492405
    },
    {
      "text": "If it's been reverse-engineered somewhat you can probably find the I2C setup calls and find the address that way.",
      "metadata": {
        "id": "1353824203878699018",
        "author": "danhalbert",
        "timestamp": "2025-03-24T16:14:03.042-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.55410128224632
    },
    {
      "text": "The original firmware worked with an (unavailable) iOS app, so much of the future use would be with a new firmware (people have started bringing up the peripherals in Arduino)",
      "metadata": {
        "id": "1353828758494118069",
        "author": "20goto10",
        "timestamp": "2025-03-24T16:32:08.947-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5712752438224428
    },
    {
      "text": "ow it overcurrents and shuts down the usb port almost instantly, lol. I  have a usb power-blocking adaptor arriving today so i can still access the microcontroller from the computer, and i'll hook my bench supply up to the boards, that way i can do the development and also i'll have an actual measurement of how much power i really need.",
      "metadata": {
        "id": "1359186542475874344",
        "author": "dgarlans",
        "timestamp": "2025-04-08T11:22:04.191-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5554792526905341
    },
    {
      "text": "Yes, if that is the only I2C device you should be able to get away with 10k resistors",
      "metadata": {
        "id": "1369657746802212954",
        "author": "skerr92",
        "timestamp": "2025-05-07T08:50:53.848-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5756073781358831
    },
    {
      "text": "And what kinds of things in software control would cause corrosion?",
      "metadata": {
        "id": "1372372538465718374",
        "author": "doublefelix",
        "timestamp": "2025-05-14T20:38:30.619-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5724052599973972
    },
    {
      "text": "ssible the library is setting the \"EXTGCK\" bit that's used for daisy-chaining multiple chips together in lockstep so it's using the SPI clock instead of it's internal clock? I'd need to dig into that code a bit.\n\nThe chip has no 'commands' really it just expects to be dumped data, it buffers 28 bytes worth and any overflow is passed out on it's SPI out port for daisy-chaining multiple chips together.\n\nThen if there's at least 8 clock cycles worth of delay in the SPI clock it'll check if the 6 MS",
      "metadata": {
        "id": "1381159916206559293",
        "author": "wolfwings",
        "timestamp": "2025-06-08T02:36:24.734-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5908660482337673
    },
    {
      "text": "Thank you!\nThe USB post on my SBC was protected from damage from this circuit by the USB hub.",
      "metadata": {
        "id": "1383073218033881209",
        "author": "204maker",
        "timestamp": "2025-06-13T09:19:11.437-04:00",
        "channel": "Adafruit_helpwithhwdesign"
      },
      "similarity": 0.5625880983913563
    }
  ]
}