ECE722 LAB 4 - COMPREHENSIVE SUMMARY FOR CHATGPT

Generated: 11/29/2025

Source: 196 Discord messages from homework-logistics + homework-help channels (Nov 24-29, 2025)

======================================================================
COPY EVERYTHING BELOW THIS LINE AND PASTE INTO CHATGPT
======================================================================

I'm working on ECE722 Lab 4 (2048-bit Adder with Prefix Tree Optimization). Below is a comprehensive summary of all discussions from the Discord channels (Nov 24-29, 2025). Please help me understand the key concepts and solve any issues I'm facing.

======================================================================
LAB 4 OVERVIEW
======================================================================

**What is Lab 4?**
- Design and implement a 2048-bit adder using techniques from Lab 3
- Two main objectives:
  1. **Naive 2048-bit Adder:** Implement using RCA or CSA from Lab 3, focus on high Fmax
  2. **Clever 2048-bit Adder:** Implement Type-2 prefix adder from Monster Adders paper
- Both adders must be pipelined for maximum performance
- Synthesize using Quartus (Intel FPGA tools)
- Optimize for high frequency (Fmax) and low ALM utilization
- Manage Quartus runtime (don't let CAD runs take forever)

**Key Files:**
- `rtl/naiveadder2048b.sv` - 2048-bit adder using RCA/CSA techniques
- `rtl/cleveradder2048b.sv` - Type-2 prefix adder implementation
- `rtl/prefix_tree.sv` - Parametric prefix tree (Kogge-Stone, Sklansky, or Brent-Kung)
- `rtl/rca_pipe.sv` - Reused from Lab 3 (pipelined RCA chunks)
- `tb/test_adder.sv` - Testbench
- `tb/test_prefix_tree.sv` - Prefix tree testbench
- `Makefile` - Build and test commands
- `env.sh` - Environment setup
- `naive.sh` / `clever.sh` - Scripts to run best solution (no sweep!)
- `results/winner_naive.csv` - Best naive adder metrics
- `results/winner_clever.csv` - Best clever adder metrics

**Timeline:**
- Lab 4 released: Nov 24, 2025
- Discussion period: Nov 24-29, 2025
- Students actively working and debugging

**Grading:**
- Autograding enabled (no parameter sweeping during grading!)
- Must set module params in RTL to your best values
- Scripts `naive.sh` and `clever.sh` must run fitting and populate winner CSVs in one shot
- Focus: High Fmax, low ALM usage, reasonable Quartus runtime

======================================================================
KEY TECHNICAL CONCEPTS
======================================================================

**1. Type-2 Adder Architecture (from Monster Adders paper):**

High-level structure:
```
Row 1: RCA chunks (each chunk computes A+B+0 and A+B+1)
       → Generates G (generate) and P (propagate) signals per chunk

Row 2: Prefix Network (size P = W/M)
       → Computes final carry-in for each chunk
       → Use Kogge-Stone, Sklansky, or Brent-Kung

Row 3: Final adders (select sum based on carry from prefix network)
       → Add carry to intermediate result
```

**Important Note from Lab Instructions:**
- "This diagram has an intentional bug around c_in and c_out of the entire adder"
- Students must identify and fix this bug
- For simplicity: treat c_in=1 as simple addition (A+B+1), NOT subtraction (A+~B+1)

**2. Parameters:**
- **W**: Adder width (2048 bits for this lab)
- **M**: Chunk size for RCA (number of bits per RCA block)
- **N**: Size of prefix tree (N = W/M = number of chunks)
- **P**: Same as N (used interchangeably in discussions)

**Key Relationships:**
- N (prefix tree size) = W / M
- Example: W=2048, M=64 → N=32 (32-input prefix tree)
- N must be a power of 2 for prefix trees (simplicity assumption)

**3. Prefix Tree Types:**
- **Kogge-Stone**: Fastest (minimum depth), but most area (fan-out of 2 at each level)
- **Sklansky**: Medium speed, medium area
- **Brent-Kung**: Slowest, least area (fan-out minimized)
- Students can choose any type for `prefix_tree.sv`

**4. Pipelining Strategy:**
- Must pipeline at least inputs and outputs
- Can use retiming registers (Quartus optimization)
- Can use Hyperflex registers (Intel's adaptive retiming)
- Flexibility in where to add pipeline stages (between rows, within prefix tree, etc.)

**5. Generate (G) and Propagate (P) Signals:**
- Each RCA chunk produces:
  - **G (Generate)**: Carry-out when c_in=0 (from A+B+0)
  - **P (Propagate)**: Carry-out when c_in=1 (from A+B+1)
- Prefix network uses G and P to compute final carries

======================================================================
COMMON ISSUES & BUGS
======================================================================

**1. Testbench Issues:**

**Issue:** `naiveadder2048b` missing `in_valid` and `out_valid` signals
- **Error:** Testbench won't work without these signals
- **Solution:** Add `in_valid` and `out_valid` ports to `naiveadder2048b.sv`
- **Professor confirmed:** "yes it needs the valids too"

**Issue:** Output port name mismatch (`s` vs `sum`)
- **Error:** `naiveadder` should have its output pin `s` renamed to `sum` to align with `test_adder.sv` tb
- **Solution:** Rename output port from `s` to `sum`
- **Professor:** "Thanks that too" (acknowledged the fix)

**Issue:** Testbench error in `test_adder.sv`
- **Error:** Verilator complaining about declaration/assignment
- **Solution:** Split declaration and assignment
- **Student:** "Verilator being Verilator and complaining"
- **Professor:** "Yeah this was fixed in my solution"

**2. Data Generation Issues:**

**Issue:** Test data is 512-bit, not 2048-bit
- **Symptom:** `a.hex` and `b.hex` under `data/` are 512-bit numbers, not 2048
- **Root cause:** Incorrect width parameter in data generation
- **Solution:** Run `make data DUT=<youradder> W=2048 M=<...>`
  - Example: `make data DUT=naiveadder2048b W=2048`
  - The Makefile will call `generate_adder_data.py --width 2048`
- **Professor:** "did you do `make data...`?"
- **Key lesson:** Always use Makefile targets, not raw Python commands

**Issue:** Test cases fail with c_out=1
- **Symptom:** "that will fail all test cases that expect c_out=1 because MSB will just be in sum instead of overflow to cout"
- **Cause:** Using 512-bit inputs with 2048-bit adder → MSB overflow goes to sum, not cout
- **Solution:** Generate proper 2048-bit test data

**3. Synthesis Issues:**

**Issue:** Quartus runtime is too long
- **Discussion:** Students concerned about CAD runs taking forever
- **Advice:** Choose M carefully to balance Fmax and ALM usage
- **Larger M** → fewer pipeline stages → faster Quartus compile → lower Fmax
- **Smaller M** → more pipeline stages → slower Quartus compile → higher Fmax

**4. Verilator Issues:**

**Issue:** Verilator syntax errors
- **Student:** "I have 100 lines of verilator errors"
- **Common causes:**
  - Declaration/assignment split issues
  - Parametric Verilog syntax
  - Module instantiation errors

**5. Prefix Tree Issues:**

**Issue:** Confusion about prefix tree size
- **Question:** "so we are actually using 512-bit input and pad 0's to make it 2048 bit?"
- **Professor:** "No?" (test data should be full 2048-bit)
- **Clarification:** N (prefix tree size) = W/M, not related to padding

======================================================================
DESIGN DECISIONS & OPTIMIZATION
======================================================================

**1. Choosing M (Chunk Size):**

**Key Tradeoffs:**
- **Small M (e.g., M=16):**
  - More RCA chunks → larger prefix tree (N=128)
  - Higher Fmax (more pipelining)
  - More ALMs (more registers)
  - Longer Quartus runtime
  
- **Large M (e.g., M=256):**
  - Fewer RCA chunks → smaller prefix tree (N=8)
  - Lower Fmax (less pipelining)
  - Fewer ALMs
  - Faster Quartus runtime

**Recommended Approach:**
- Start with medium M (e.g., M=64, N=32)
- Test a few values
- Pick best balance for winner CSV

**2. Naive Adder: RCA vs CSA?**

**Student question:** "If we wanna use CSA for our `naiveadder`, we can add an M parameter here right?"
- **Professor:** "Bake it in (M)"
- **Implication:** You can use either RCA or CSA from Lab 3
- **Likely best choice:** CSA (faster than RCA, proven in Lab 3)
- **Remember:** Add M parameter for pipelining

**3. Prefix Tree Type:**

**No explicit guidance in discussions, but theory suggests:**
- **Kogge-Stone:** Best for Fmax (minimum depth)
- **Brent-Kung:** Best for ALM usage (minimum area)
- **Sklansky:** Middle ground

**Student choice:** Implement parametrically and test different types?
- Lab only requires ONE type
- Choose based on your optimization goal

**4. Pipelining Strategy:**

**Required:**
- Input registers (all inputs: a, b, c_in, in_valid)
- Output registers (all outputs: sum, c_out, out_valid)

**Optional (for higher Fmax):**
- Pipeline registers between Row 1 and Row 2
- Pipeline registers between Row 2 and Row 3
- Pipeline registers WITHIN prefix tree (between levels)

**Tools:**
- Retiming: Let Quartus move registers automatically
- Hyperflex: Intel's adaptive retiming for maximum Fmax

**5. Latency Management:**

**Critical:** `out_valid` must align with actual output
- Count pipeline stages
- Delay `in_valid` by latency cycles
- Output `out_valid` when sum is ready

**Example:**
```systemverilog
// If latency = 5 cycles:
logic [4:0] valid_shift;
always_ff @(posedge clk) begin
    valid_shift <= {valid_shift[3:0], in_valid};
end
assign out_valid = valid_shift[4];
```

======================================================================
MAKEFILE COMMANDS
======================================================================

**Data Generation:**
```bash
make data DUT=naiveadder2048b W=2048 TESTS=100
make data DUT=cleveradder2048b W=2048 TESTS=100
make data DUT=prefix_tree N=32 TESTS=100
```

**Simulation:**
```bash
make sim DUT=naiveadder2048b W=2048 M=64
make sim DUT=cleveradder2048b W=2048 M=64
make sim DUT=prefix_tree N=32
```

**Synthesis:**
```bash
make synth DUT=naiveadder2048b W=2048 M=64
make synth DUT=cleveradder2048b W=2048 M=64
make synth DUT=prefix_tree N=32
```

**Fitting (Full FPGA Implementation):**
```bash
make fit DUT=naiveadder2048b W=2048 M=64
make fit DUT=cleveradder2048b W=2048 M=64
make fit DUT=prefix_tree N=32
```

**Extract Metrics:**
```bash
make extract DUT=naiveadder2048b W=2048 M=64
make extract DUT=cleveradder2048b W=2048 M=64
```

**Professor's Reminder:**
"Check the Makefile - there's a data target"
"Use `make data DUT=<youradder> W=2048`"

======================================================================
AUTOGRADING REQUIREMENTS
======================================================================

**Critical for Grading:**

1. **Set module params in RTL to best values:**
   - Don't leave M as a parameter that needs to be set externally
   - Hard-code your best M value in the module definition
   - Example: `module naiveadder2048b #(parameter W=2048, parameter M=64) (...);`

2. **Create `naive.sh` script:**
   - Must run fitting for naive adder
   - Must populate `results/winner_naive.csv`
   - Must do everything in ONE SHOT (no manual sweeping)
   - Example:
     ```bash
     #!/bin/bash
     make fit DUT=naiveadder2048b W=2048 M=64
     make extract DUT=naiveadder2048b W=2048 M=64
     # (extract script populates winner_naive.csv)
     ```

3. **Create `clever.sh` script:**
   - Same as above, but for clever adder
   - Populates `results/winner_clever.csv`

4. **Commit required files:**
   ```bash
   git add rtl/*.sv
   git add tb/test_prefix_tree.sv
   git add naive.sh clever.sh
   git add results/*.csv
   git commit -m "i am done, are you ready to be amazed prof?"
   git push origin master
   ```

**Warning from Lab Instructions:**
"To avoid sweeping during grading, make sure the module params in the RTL are set to correct best values you want."
(This is repeated TWICE in the instructions - very important!)

======================================================================
DEBUGGING TIPS
======================================================================

**1. Always source env.sh first:**
```bash
source env.sh
```

**2. Check test data width:**
```bash
# Verify a.hex and b.hex are 2048-bit (512 hex digits):
wc -c data/a.hex  # Should be 513 bytes (512 hex + newline)
```

**3. Verify module ports:**
- naiveadder2048b needs: `in_valid`, `out_valid`, `sum` (not `s`)
- cleveradder2048b needs: same
- prefix_tree needs: appropriate G/P inputs, carry outputs

**4. Simulation before synthesis:**
- Always run `make sim` before `make fit`
- Catch logic errors early (synthesis takes much longer)

**5. Check latency calculation:**
- Count pipeline stages manually
- Verify `out_valid` timing in simulation waveform
- Mismatch errors usually mean wrong latency

**6. Monitor Quartus runtime:**
- If `make fit` takes > 30 minutes, consider larger M
- Balance between Fmax optimization and practical compile time

**7. Verilator errors:**
- If you get 100 lines of errors, check:
  - Declaration/assignment split
  - Port name mismatches
  - Parametric Verilog syntax

**8. Use testbench for prefix_tree:**
- There's a separate `test_prefix_tree.sv` testbench
- Test prefix tree independently before integrating

======================================================================
PROFESSOR'S ADVICE & CLARIFICATIONS
======================================================================

**On M parameter:**
- "Bake it in (M)" - hard-code your best M value

**On valid signals:**
- "yes it needs the valids too" - all adders need in_valid and out_valid

**On test data:**
- "did you do `make data...`?" - use Makefile, not raw Python
- "Check the Makefile - there's a data target"

**On data width:**
- "No?" - when asked if using 512-bit inputs (should be 2048-bit)
- "Is my random generator producing large numbers???" - rhetorical, checking test data

**On testbench fixes:**
- "Thanks that too" - acknowledged output port name fix
- "Yeah this was fixed in my solution" - testbench issue already known

**On Verilator:**
- "Pretty much" - when student said declaration/assignment split
- "Verilator being Verilator and complaining" - known Verilator quirk

======================================================================
PREFIX TREE IMPLEMENTATION NOTES
======================================================================

**Prefix Tree Theory:**
- Computes parallel prefix operation on (G, P) pairs
- Each level combines pairs: (Gi, Pi) ⊕ (Gj, Pj) = (Gi + Pi·Gj, Pi·Pj)
- Output: Cumulative generate signals (final carries for each chunk)

**Kogge-Stone Structure:**
- Log₂(N) levels
- Each level doubles the span
- Level 0: span=1, Level 1: span=2, Level 2: span=4, etc.
- Maximum parallelism, minimum depth

**Implementation Tips:**
1. **Use parametric generate blocks:**
   ```systemverilog
   genvar level, i;
   generate
       for (level = 0; level < $clog2(N); level++) begin : level_loop
           for (i = 0; i < N; i++) begin : node_loop
               // Prefix computation
           end
       end
   endgenerate
   ```

2. **Boundary conditions:**
   - First node at each level may have different logic
   - Handle i < span cases

3. **Pipelining:**
   - Can add registers between levels
   - Increases latency but improves Fmax

4. **Test independently:**
   - Use `test_prefix_tree.sv` testbench
   - Verify with small N (e.g., N=8) first
   - Check waveforms for correct carry propagation

**Reference:**
"There's a parameter N which determines the size of the tree and can be assumed to be a power of 2 for simplicity."
"The prefix RTL can be modeled on the code available in the yosys repository suitably adapted for use in this lab."

======================================================================
TYPE-2 ADDER IMPLEMENTATION NOTES
======================================================================

**Row 1: RCA Chunks**
```systemverilog
// For each chunk i (0 to N-1):
// Compute A[i*M +: M] + B[i*M +: M] + 0 → sum0, G[i]
// Compute A[i*M +: M] + B[i*M +: M] + 1 → sum1, P[i]

// Can instantiate rca_pipe.sv twice per chunk
// Or optimize: only need carry-out bits for G/P
```

**Row 2: Prefix Network**
```systemverilog
// Instantiate prefix_tree.sv
prefix_tree #(.N(P)) prefix_inst (
    .clk(clk),
    .g_in(G),   // Generate signals from Row 1
    .p_in(P),   // Propagate signals from Row 1
    .c_out(C)   // Final carries for each chunk
);
```

**Row 3: Final Adders**
```systemverilog
// For each chunk i:
// If C[i] == 0: final_sum[i*M +: M] = sum0[i]
// If C[i] == 1: final_sum[i*M +: M] = sum1[i]

// Or: Add C[i] to base sum using small adders
// Depends on your Row 1 implementation
```

**Critical Bug to Fix:**
"This diagram has an intentional bug around c_in and c_out of the entire adder"
- Check how c_in (carry-in to entire adder) is handled
- Check how c_out (carry-out from entire adder) is computed
- For simplicity: c_in=1 means A+B+1 (not subtraction)

**Potential Bug Locations:**
- c_in might not feed into first chunk correctly
- c_out might not account for final carry from last chunk
- G/P generation might not consider overall c_in

======================================================================
PARAMETER CHOICES & EXAMPLES
======================================================================

**Example 1: Balanced Design**
- W = 2048
- M = 64
- N = 32 (prefix tree size)
- Moderate Fmax, moderate ALM usage
- Reasonable Quartus runtime

**Example 2: High Fmax Design**
- W = 2048
- M = 32
- N = 64 (prefix tree size)
- Higher Fmax (more pipelining)
- More ALMs
- Longer Quartus runtime

**Example 3: Low Area Design**
- W = 2048
- M = 128
- N = 16 (prefix tree size)
- Lower Fmax
- Fewer ALMs
- Faster Quartus runtime

**Recommendation:**
- Test 2-3 values of M
- Pick best balance for your optimization goal
- Document your choice in comments

======================================================================
COMMON ERRORS & SOLUTIONS
======================================================================

**Error 1: "tb won't work" (missing in_valid/out_valid)**
```
Error: Testbench expects in_valid and out_valid signals
```
**Solution:** Add these ports to your adder module

---

**Error 2: "align with the test_adder.sv tb" (port name mismatch)**
```
Error: Port 's' not found, expected 'sum'
```
**Solution:** Rename output port from `s` to `sum`

---

**Error 3: "Test cases fail with c_out=1" (wrong data width)**
```
Error: Expected c_out=1 but got c_out=0
```
**Solution:** Generate correct 2048-bit test data:
```bash
make data DUT=naiveadder2048b W=2048
```

---

**Error 4: "100 lines of verilator errors"**
**Solution:** 
- Check declaration/assignment split
- Verify parametric Verilog syntax
- Review module instantiation

---

**Error 5: "Quartus runtime too long"**
**Solution:** Increase M (fewer chunks, smaller prefix tree)

---

**Error 6: "Simulation mismatch"**
**Solution:** Check latency calculation and out_valid timing

======================================================================
QUESTIONS TO ASK CHATGPT (EXAMPLES)
======================================================================

After pasting this summary, you can ask ChatGPT:

1. "How do I structure the Type-2 adder with three rows (RCA chunks, prefix tree, final adders)?"

2. "How do I compute G (generate) and P (propagate) signals from RCA chunks?"

3. "What's the best prefix tree type for high Fmax: Kogge-Stone, Sklansky, or Brent-Kung?"

4. "How do I implement a Kogge-Stone prefix tree in SystemVerilog with parameter N?"

5. "How do I calculate latency for the Type-2 adder with pipelining?"

6. "What M value should I choose for 2048-bit adder to balance Fmax and ALM usage?"

7. "How do I handle the c_in and c_out bug mentioned in the lab instructions?"

8. "Should I use RCA or CSA for the naive adder? Which is faster?"

9. "How do I pipeline the prefix tree? Should I add registers between levels?"

10. "How do I implement the final adder stage (Row 3) to select between sum0 and sum1?"

11. "What's the difference between retiming and Hyperflex registers in Quartus?"

12. "How many ALMs should a 2048-bit prefix adder use?"

13. "How do I verify my prefix tree is working correctly before integrating it?"

14. "How do I write naive.sh and clever.sh scripts for autograding?"

15. "How do I hard-code the M parameter in my module definition?"

16. "Why are my test cases only 512-bit instead of 2048-bit?"

17. "How do I split declaration and assignment to fix Verilator errors?"

18. "What's the expected Fmax for a well-optimized 2048-bit adder on this FPGA?"

19. "How do I balance Quartus runtime vs. Fmax optimization?"

20. "What are the key differences between naive and clever adders in terms of architecture?"

======================================================================
ADDITIONAL RESOURCES
======================================================================

**Monster Adders Paper:**
- Read the Type-2 adder section carefully
- Understand the three-row architecture
- Identify the intentional bug in the diagram

**Yosys Repository:**
- Contains reference prefix tree implementations
- Adapt the code for this lab (parametric N, proper I/O)

**Lab 3 Solutions:**
- Reuse rca_pipe.sv and csa_pipe.sv
- Copy pipelining strategies
- Apply same optimization techniques

**Quartus Documentation:**
- Retiming settings
- Hyperflex registers
- Timing analysis reports

======================================================================
END OF SUMMARY - PASTE EVERYTHING ABOVE INTO CHATGPT
======================================================================

Generated from 196 Discord messages (Nov 24-29, 2025)
Full message archive: ece722_lab4_ALL_MESSAGES.txt




